/*
 * Copyright (C) 2020 GreenWaves Technologies, SAS, ETH Zurich and
 *                    University of Bologna
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Authors: Germain Haugou, GreenWaves Technologies (germain.haugou@greenwaves-technologies.com)
 */

#include <vp/vp.hpp>
#include "cpu/iss/include/iss.hpp"
#include "vp/signal.hpp"

void Lsu::reset(bool active)
{
    if (active)
    {
        this->elw_stalled.set(false);
        this->misaligned_size = 0;
        this->io_req_denied = false;
    }
}

void Lsu::exec_misaligned(vp::Block *__this, vp::ClockEvent *event)
{
    Iss *iss = (Iss *)__this;
    Lsu *_this = &iss->lsu;

    if (iss->exec.handle_stall_cycles()) return;

    _this->trace.msg(vp::Trace::LEVEL_TRACE, "Handling second half of misaligned access\n");

    // As the 2 load accesses for misaligned access are generated by the
    // wrapper, we need to account the extra access here.
    // iss->timing.stall_misaligned_account();

    iss->timing.event_load_account(1);
    iss->timing.cycle_account();

    int64_t latency;
    int req_id;
    if (_this->data_req_aligned(_this->misaligned_addr, _this->misaligned_data, _this->misaligned_memcheck_data,
                                _this->misaligned_size, _this->misaligned_is_write, latency, req_id) == vp::IO_REQ_OK)
    {
        iss->trace.dump_trace_enabled = true;
        _this->pending_latency = latency;
#ifdef CONFIG_GVSOC_ISS_LSU_NB_OUTSTANDING
        _this->stall_callback[req_id](_this, &_this->io_req[req_id]);
#else
        _this->stall_callback(_this, &_this->io_req);
#endif
        iss->exec.insn_resume();
    }
    else
    {
        _this->trace.warning("UNIMPLEMENTED AT %s %d\n", __FILE__, __LINE__);
    }

    _this->misaligned_size = 0;
}


int Lsu::data_misaligned_req(iss_addr_t addr, uint8_t *data_ptr, uint8_t *memcheck_data, int size, bool is_write, int64_t &latency)
{
    iss_addr_t addr0 = addr & ADDR_MASK;
    iss_addr_t addr1 = (addr + size - 1) & ADDR_MASK;

    this->trace.msg("Misaligned data request (addr: 0x%lx, size: 0x%x, is_write: %d)\n", addr, size, is_write);

    this->iss.timing.event_misaligned_account(1);

    // The access is a misaligned access
    // Change the event so that we can do the first access now and the next access
    // during the next cycle
    int size0 = addr1 - addr;
    int size1 = size - size0;

    // Remember the access properties for the second access
    this->misaligned_size = size1;
    this->misaligned_data = data_ptr + size0;
    this->misaligned_memcheck_data = memcheck_data + size0;
    this->misaligned_addr = addr1;
    this->misaligned_is_write = is_write;

    // And do the first one now
    int req_id;
    int err = data_req_aligned(addr, data_ptr, memcheck_data, size0, is_write, latency, req_id);
    if (err == vp::IO_REQ_OK)
    {
#if defined(PIPELINE_STALL_THRESHOLD)
        if (latency > PIPELINE_STALL_THRESHOLD)
        {
            this->iss.timing.stall_load_account(latency - PIPELINE_STALL_THRESHOLD);
        }
#endif
        // As the transaction is split into 2 parts, we must tell the ISS
        // that the access is pending as the instruction must be executed
        // only when the second access is finished.
        this->iss.exec.insn_hold(&Lsu::exec_misaligned);
        return vp::IO_REQ_PENDING;
    }
    else
    {
        return vp::IO_REQ_INVALID;
    }
}

void Lsu::data_grant(vp::Block *__this, vp::IoReq *req)
{
#ifdef CONFIG_GVSOC_ISS_LSU_NB_OUTSTANDING
    // The denied request is granted, we can now allow the core to do other accesses
    Lsu *_this = (Lsu *)__this;
    _this->io_req_denied = false;
    _this->iss.exec.stalled_dec();
#endif
}

void Lsu::data_response(vp::Block *__this, vp::IoReq *req)
{
    Lsu *_this = (Lsu *)__this;
    Iss *iss = &_this->iss;

#ifndef CONFIG_GVSOC_ISS_LSU_NB_OUTSTANDING
    iss->exec.stalled_dec();
#endif

    _this->trace.msg("Received data response (req: %p, stalled: %d)\n", req, iss->exec.stalled.get());

    // First call the ISS to finish the instruction

#ifdef CONFIG_GVSOC_ISS_LSU_NB_OUTSTANDING
    _this->pending_latency = 0;
    int req_id = *((int *)req->arg_get(0));
    // Call the access termination callback only we the access is not misaligned since
    // in this case, the second access with handle it.
    if (_this->misaligned_size == 0)
    {
        _this->stall_callback[req_id](_this, req);
    }
    _this->free_req(req, 0);
#else
    _this->pending_latency = req->get_latency() + 1;
    // Call the access termination callback only we the access is not misaligned since
    // in this case, the second access with handle it.
    if (_this->misaligned_size == 0)
    {
        _this->stall_callback(_this, req);
    }
#endif
}

int Lsu::data_req_aligned(iss_addr_t addr, uint8_t *data_ptr, uint8_t *memcheck_data, int size, bool is_write, int64_t &latency, int &req_id)
{
    this->trace.msg("Data request (addr: 0x%lx, size: 0x%x, is_write: %d)\n", addr, size, is_write);
    vp::IoReq *req = this->get_req();
    if (req == NULL)
    {
        // If there is no more request, returns DENIED, as this will have the same effect of
        // stalling the core
        req_id = -1;
        return vp::IO_REQ_DENIED;
    }
    req->prepare();
    req->set_addr(addr);
    req->set_size(size);
    req->set_is_write(is_write);
#ifdef CONFIG_GVSOC_ISS_LSU_NB_OUTSTANDING
    if (is_write)
    {
        // Since accesses are not blocking and the store may use input data later, we need
        // to save it to the request
        uint8_t *req_data = (uint8_t *)&this->req_data[*((int *)req->arg_get(0))];
        *(iss_reg_t *)req_data = *(iss_reg_t *)data_ptr;
        data_ptr = req_data;
    }
#endif
    req->set_data(data_ptr);
#ifdef VP_MEMCHECK_ACTIVE
    if (!is_write && memcheck_data)
    {
        memset(memcheck_data, 0xFF, size);
    }

    req->set_memcheck_data(memcheck_data);
#endif

    this->log_addr.set_and_release(addr);
    this->log_size.set_and_release(size);
    this->log_is_write.set_and_release(is_write);

    int err = this->data.req(req);

    if (err == vp::IO_REQ_OK)
    {
        #ifndef CONFIG_GVSOC_ISS_SNITCH
        latency = req->get_latency() + 1;
        #else
        // In case of a write, don't signal a valid transaction. Stores are always
        // without ans answer to the core.
        if (is_write)
        {
            // Suppress stores
            latency = req->get_latency();
        }
        else
        {
            // Load needs one more cycle to write result back from tcdm/mem response.
            latency = req->get_latency() + 1;
        }
        #endif

    #ifdef CONFIG_GVSOC_ISS_LSU_NB_OUTSTANDING
        // For synchronous requests, free the request now with the proper latency, so that
        // it becomes available only after the latency has ellapsed
        this->free_req(req, this->iss.top.clock.get_cycles() + latency);
    #endif


        return 0;
    }
    else if (err == vp::IO_REQ_INVALID)
    {
        latency = req->get_latency() + 1;

#ifndef CONFIG_GVSOC_ISS_RISCV_EXCEPTIONS
        if (this->iss.gdbserver.gdbserver)
        {
            this->trace.msg(vp::Trace::LEVEL_WARNING,"Invalid access (pc: 0x%" PRIxFULLREG ", offset: 0x%" PRIxFULLREG ", size: 0x%x, is_write: %d)\n",
                            this->iss.exec.current_insn, addr, size, is_write);
            this->iss.exec.stalled_inc();
            this->iss.exec.halted.set(true);
            this->iss.gdbserver.gdbserver->signal(&this->iss.gdbserver, vp::Gdbserver_engine::SIGNAL_BUS);
        }
        else
        {
            vp_warning_always(&this->trace,
                            "Invalid access (pc: 0x%" PRIxFULLREG ", offset: 0x%" PRIxFULLREG ", size: 0x%x, is_write: %d)\n",
                            this->iss.exec.current_insn, addr, size, is_write);
        }
#else
        int trap = is_write ? ISS_EXCEPT_STORE_FAULT : ISS_EXCEPT_LOAD_FAULT;
        this->iss.exception.raise(this->iss.exec.current_insn, trap);
#endif
        return err;
    }

#ifdef CONFIG_GVSOC_ISS_LSU_NB_OUTSTANDING
    req_id = *((int *)req->arg_get(0));
    if (err == vp::IO_REQ_DENIED)
    {
        // In case the request is denied, make sure we don't allow any other access
        // until this request is granted
        this->io_req_denied = true;
        this->iss.exec.insn_stall();
    }
    else if (err == vp::IO_REQ_PENDING)
    {
        // In case the request is pending, don't do anything, we will free
        // the request and update the scoreboard when the response is received
    }
#else
    this->trace.msg(vp::Trace::LEVEL_TRACE, "Waiting for asynchronous response\n");
    this->iss.exec.insn_stall();
#endif
    return err;
}

#ifdef CONFIG_GVSOC_ISS_LSU_NB_OUTSTANDING
bool Lsu::lsu_is_empty()
{
    vp::IoReq *req = this->io_req_first;
    int64_t cycles = this->iss.top.clock.get_cycles();
    for (int i = 0; i < CONFIG_GVSOC_ISS_LSU_NB_OUTSTANDING; i++)
    {
        if (req == NULL || *((int64_t *)req->arg_get(1)) > cycles)
            return false;
        req = req->get_next();
    }
    return true;
}
#endif

int Lsu::data_req(iss_addr_t addr, uint8_t *data_ptr, uint8_t *memcheck_data, int size, bool is_write, int64_t &latency, int &req_id)
{
#if !defined(CONFIG_GVSOC_ISS_HANDLE_MISALIGNED)

    return this->data_req_aligned(addr, data_ptr, memcheck_data, size, is_write, latency, req_id);

#else

    iss_addr_t addr0 = addr & ADDR_MASK;
    iss_addr_t addr1 = (addr + size - 1) & ADDR_MASK;

#if defined(CONFIG_GVSOC_ISS_SNITCH) && !defined(CONFIG_GVSOC_ISS_SNITCH_FAST)

    // Todo: solve misaligned data request issue of fp subsystem by enqueue acceleration request
    if (likely(addr0 == addr1) || this->iss.fp_ss)
        return this->data_req_aligned(addr, data_ptr, size, is_write, latency, req_id);
    else
        return this->data_misaligned_req(addr, data_ptr, size, is_write, latency);
#else
    if (likely(addr0 == addr1))
        return this->data_req_aligned(addr, data_ptr, memcheck_data, size, is_write, latency, req_id);
    else
        return this->data_misaligned_req(addr, data_ptr, memcheck_data, size, is_write, latency);

#endif
#endif
}

Lsu::Lsu(IssWrapper &top, Iss &iss)
    : iss(iss),
    log_addr(top, "lsu/addr", ISS_REG_WIDTH, vp::SignalCommon::ResetKind::HighZ),
    log_size(top, "lsu/size", ISS_REG_WIDTH, vp::SignalCommon::ResetKind::HighZ),
    log_is_write(top, "lsu/is_write", 1, vp::SignalCommon::ResetKind::HighZ),
    stalled(top, "lsu/stalled", 1),
    io_req_denied(top, "lsu/req_denied", 1)
{
}

void Lsu::build()
{
    iss.top.traces.new_trace("lsu", &this->trace, vp::DEBUG);
    data.set_resp_meth(&Lsu::data_response);
    data.set_grant_meth(&Lsu::data_grant);
    this->iss.top.new_master_port("data", &data, (vp::Block *)this);
    this->iss.top.new_master_port("meminfo", &this->meminfo, (vp::Block *)this);

    this->iss.top.new_reg("elw_stalled", &this->elw_stalled, false);

    this->memory_start = -1;
    this->memory_end = -1;

    if (this->iss.top.get_js_config()->get("memory_start") != NULL)
    {
        this->memory_start = this->iss.top.get_js_config()->get("memory_start")->get_int();
        this->memory_end = this->memory_start +
            this->iss.top.get_js_config()->get("memory_size")->get_int();
    }

#ifdef CONFIG_GVSOC_ISS_LSU_NB_OUTSTANDING
    this->io_req_first = NULL;
    for (int i=0; i<CONFIG_GVSOC_ISS_LSU_NB_OUTSTANDING; i++)
    {
        vp::IoReq *req = &this->io_req[i];
        req->arg_alloc(2);
        // The queue of free requests is organized from lowest cyclestamp to highest. Set to 0
        // at build time.
        *((int64_t *)req->arg_get(1)) = 0;
        // ID of the request, used to handle responses
        *((int *)req->arg_get(0)) = i;

        req->set_next(this->io_req_first);
        this->io_req_first = req;
    }
#endif
}

void Lsu::start()
{
#ifdef CONFIG_GVSOC_ISS_MEMORY
    this->meminfo.sync_back((void **)&this->mem_array);
#endif
}

void Lsu::store_resume(Lsu *lsu, vp::IoReq *req)
{
    // For now we don't have to do anything as the register was written directly
    // by the request but we cold support sign-extended loads here;
#ifdef CONFIG_GVSOC_ISS_LSU_NB_OUTSTANDING
    int req_id = *((int *)req->arg_get(0));
    lsu->iss.exec.insn_terminate(false, lsu->stall_insn[req_id]);
#else
    lsu->iss.exec.insn_terminate();
#endif
}

void Lsu::load_resume(Lsu *lsu, vp::IoReq *req)
{
    // Nothing to do, the zero-extension was done by initializing the register to 0

#ifdef CONFIG_GVSOC_ISS_LSU_NB_OUTSTANDING
    int req_id = *((int *)req->arg_get(0));
    int reg = lsu->stall_reg[req_id];
#else
    int reg = lsu->stall_reg;
#endif
#ifdef CONFIG_GVSOC_ISS_SCOREBOARD
    lsu->iss.regfile.scoreboard_reg_set_timestamp(reg, lsu->pending_latency + 1, CSR_PCER_LD_STALL);
#endif
#if defined(PIPELINE_STALL_THRESHOLD)
        if (lsu->pending_latency > PIPELINE_STALL_THRESHOLD)
        {
            lsu->iss.timing.stall_load_account(lsu->pending_latency - PIPELINE_STALL_THRESHOLD);
        }
#endif

#ifdef CONFIG_GVSOC_ISS_LSU_NB_OUTSTANDING
    lsu->iss.exec.insn_terminate(false, lsu->stall_insn[req_id]);
#else
    lsu->iss.exec.insn_terminate();
#endif
}

void Lsu::elw_resume(Lsu *lsu, vp::IoReq *req)
{
    // Clear pending elw to not replay it when the next interrupt occurs
    lsu->iss.exec.insn_terminate();
    lsu->iss.exec.elw_insn = 0;
    lsu->elw_stalled.set(false);
    lsu->iss.exec.busy_enter();
}

void Lsu::load_signed_resume(Lsu *lsu, vp::IoReq *req)
{
#ifdef CONFIG_GVSOC_ISS_LSU_NB_OUTSTANDING
    int req_id = *((int *)req->arg_get(0));
    int reg = lsu->stall_reg[req_id];
    int stall_size = lsu->stall_size[req_id];
#else
    int reg = lsu->stall_reg;
    int stall_size = lsu->stall_size;
#endif
    lsu->iss.regfile.set_reg(reg, iss_get_signed_value(lsu->iss.regfile.get_reg(reg),
        stall_size * 8));

    // Due to sign extension, whole register is valid only if sign is valid
    lsu->iss.regfile.memcheck_set_valid(reg, (lsu->iss.regfile.memcheck_get(reg) >> (stall_size *8)) & 1);

#ifdef CONFIG_GVSOC_ISS_SCOREBOARD
    lsu->iss.regfile.scoreboard_reg_set_timestamp(reg, lsu->pending_latency + 1, CSR_PCER_LD_STALL);
#endif
#if defined(PIPELINE_STALL_THRESHOLD)
        if (lsu->pending_latency > PIPELINE_STALL_THRESHOLD)
        {
            lsu->iss.timing.stall_load_account(lsu->pending_latency - PIPELINE_STALL_THRESHOLD);
        }
#endif

#ifdef CONFIG_GVSOC_ISS_LSU_NB_OUTSTANDING
    lsu->iss.exec.insn_terminate(false, lsu->stall_insn[req_id]);
#else
    lsu->iss.exec.insn_terminate();
#endif
}

void Lsu::load_float_resume(Lsu *lsu, vp::IoReq *req)
{
#ifdef CONFIG_GVSOC_ISS_LSU_NB_OUTSTANDING
    int req_id = *((int *)req->arg_get(0));
    int reg = lsu->stall_reg[req_id];
    int stall_size = lsu->stall_size[req_id];
#else
    int reg = lsu->stall_reg;
    int stall_size = lsu->stall_size;
#endif
    lsu->iss.regfile.set_freg(reg, iss_get_float_value(lsu->iss.regfile.get_freg(reg),
        stall_size * 8));
#ifdef CONFIG_GVSOC_ISS_SCOREBOARD
    lsu->iss.regfile.scoreboard_freg_set_timestamp(reg, lsu->pending_latency + 1, CSR_PCER_LD_STALL);
#endif
#if defined(PIPELINE_STALL_THRESHOLD)
        if (lsu->pending_latency > PIPELINE_STALL_THRESHOLD)
        {
            lsu->iss.timing.stall_load_account(lsu->pending_latency - PIPELINE_STALL_THRESHOLD);
        }
#endif

#ifdef CONFIG_GVSOC_ISS_LSU_NB_OUTSTANDING
    lsu->iss.exec.insn_terminate(false, lsu->stall_insn[req_id]);
#else
    lsu->iss.exec.insn_terminate();
#endif
}

bool Lsu::atomic(iss_insn_t *insn, iss_addr_t addr, int size, int reg_in, int reg_out,
    vp::IoReqOpcode opcode)
{
    iss_addr_t phys_addr;

    this->trace.msg("Atomic request (addr: 0x%lx, size: 0x%x, opcode: %d)\n", addr, size, opcode);
    vp::IoReq *req = this->get_req();
    if (req == NULL)
    {
        // If there is no more request, returns true to stall the core stall the core
        return true;
    }

    if (opcode == vp::IoReqOpcode::LR)
    {
        bool use_mem_array;
#ifdef CONFIG_GVSOC_ISS_MMU
        if (this->iss.mmu.load_virt_to_phys(addr, phys_addr, use_mem_array))
        {
            return false;
        }
#else
        phys_addr = addr;
#endif
    }
    else
    {
        bool use_mem_array;
#ifdef CONFIG_GVSOC_ISS_MMU
        if (this->iss.mmu.store_virt_to_phys(addr, phys_addr, use_mem_array))
        {
            return false;
        }
#else
        phys_addr = addr;
#endif
    }

    req->prepare();
    req->set_addr(phys_addr);
    req->set_size(size);
    req->set_opcode(opcode);
#ifdef CONFIG_GVSOC_ISS_LSU_NB_OUTSTANDING
    // Since accesses are not blocking and the store may use input data later, we need
    // to save it to the request
    uint8_t *req_data = (uint8_t *)&this->req_data[*((int *)req->arg_get(0))];
    *(iss_reg_t *)req_data = *(iss_reg_t *)this->iss.regfile.reg_store_ref(reg_in);
    req->set_data(req_data);
#else
    req->set_data((uint8_t *)this->iss.regfile.reg_store_ref(reg_in));
#endif
    req->set_second_data((uint8_t *)this->iss.regfile.reg_ref(reg_out));

// #ifdef VP_MEMCHECK_ACTIVE
//     uint8_t *memcheck_data = (uint8_t *)this->iss.regfile.reg_store_ref(reg_in);
//     memset(memcheck_data, 0xFF, size);
//     req->set_memcheck_data(memcheck_data);
//     uint8_t *check_second_data = (uint8_t *)this->iss.regfile.reg_ref(reg_out);
//     req->set_second_memcheck_data(check_second_data);
// #endif
    req->set_initiator(this->iss.csr.mhartid);

    this->log_addr.set_and_release(addr);
    this->log_size.set_and_release(size);
    this->log_is_write.set_and_release(true);

    int err = this->data.req(req);
    if (err == vp::IO_REQ_OK)
    {
        if (size != ISS_REG_WIDTH/8)
        {
            this->iss.regfile.set_reg(reg_out, iss_get_signed_value(this->iss.regfile.get_reg(reg_out), size * 8));
        }

#ifndef CONFIG_GVSOC_ISS_LSU_NB_OUTSTANDING
        if (req->get_latency() > 0)
        {
#ifdef CONFIG_GVSOC_ISS_SCOREBOARD
            this->iss.regfile.scoreboard_reg_set_timestamp(reg_out, req->get_latency() + 1, CSR_PCER_LD_STALL);
#else
            this->iss.timing.stall_load_account(req->get_latency());
#endif
        }
#else
        // For synchronous requests, free the request now with the proper latency, so that
        // it becomes available only after the latency has ellapsed
        this->free_req(req, this->iss.top.clock.get_cycles() + req->get_latency());
#endif

        return false;
    }
    else if (err == vp::IO_REQ_INVALID)
    {
        vp_warning_always(&this->iss.trace,
                          "Invalid atomic access (pc: 0x%" PRIxFULLREG ", offset: 0x%" PRIxFULLREG ", size: 0x%x, opcode: %d)\n",
                          this->iss.exec.current_insn, phys_addr, size, opcode);
        return false;
    }

    this->trace.msg(vp::Trace::LEVEL_TRACE, "Waiting for asynchronous response\n");

#ifdef CONFIG_GVSOC_ISS_LSU_NB_OUTSTANDING
    if (err == vp::IO_REQ_DENIED || err == vp::IO_REQ_PENDING)
    {
#ifdef CONFIG_GVSOC_ISS_SCOREBOARD
        this->iss.regfile.scoreboard_reg_invalidate(reg_out);
#endif
        if (err == vp::IO_REQ_DENIED)
        {
            // In case the request is denied, make sure we don't allow any other access
            // until this request is granted
            this->io_req_denied = true;
            this->iss.exec.insn_stall();
        }
        // What was the purpose of this check ?
        if (1) //size != ISS_REG_WIDTH/8)
        {
            int req_id = *((int *)req->arg_get(0));
            this->stall_callback[req_id] = &Lsu::load_signed_resume;
            this->stall_reg[req_id] = reg_out;
            this->stall_size[req_id] = size;
            this->stall_insn[req_id] = insn->addr;
        }
        else
        {
            int req_id = *((int *)req->arg_get(0));
            this->stall_callback[req_id] = &Lsu::store_resume;
            this->stall_insn[req_id] = insn->addr;
        }
    }
#else
    this->iss.exec.insn_stall();

    if (size != ISS_REG_WIDTH/8)
    {
        this->stall_callback = &Lsu::load_signed_resume;
        this->stall_reg = reg_out;
        this->stall_size = size;
    }
    else
    {
        this->stall_callback = &Lsu::store_resume;
    }
#endif

    return false;
}
